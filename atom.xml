<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://guozixu2001.github.io/</id>
    <title>Rocco&apos;s Cache</title>
    <updated>2022-06-12T12:25:31.168Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://guozixu2001.github.io/"/>
    <link rel="self" href="https://guozixu2001.github.io/atom.xml"/>
    <subtitle>Rocco写东西的Cache</subtitle>
    <logo>https://guozixu2001.github.io/images/avatar.png</logo>
    <icon>https://guozixu2001.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Rocco&apos;s Cache</rights>
    <entry>
        <title type="html"><![CDATA[RSA加密原理]]></title>
        <id>https://guozixu2001.github.io/post/rsa-jia-mi-yuan-li/</id>
        <link href="https://guozixu2001.github.io/post/rsa-jia-mi-yuan-li/">
        </link>
        <updated>2022-06-06T10:35:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>RSA加密利用了单向函数正向求解很简单，反向求解很复杂的特性。<br>
<strong>具体是利用了：</strong></p>
</blockquote>
<ul>
<li>对两个质数相乘容易，而将其合数分解很难的这个特点进行的加密算法。 n=p1*p2，已知p1、p2求n简单，已知n求p1、p2困难。</li>
<li>(m^e) mod n=c，已知m、e、n求c简单，已知e、n、c求m很难。</li>
</ul>
<p>RSA加密，实现了公开密钥，就是A可以给所有人发送锁，其他人把要加密的信息用这把锁加密后发送给A，A用自己的钥匙开锁就可以获得加密的信息了。反过来，A要发送加密信息给B，只要知道B的锁就可以了，而这个锁是公开的。公开密钥n、e的生成：随机选取两个质数p1、p2，n=p1*p2，再随机选取一个整数e，e与φ(n)互质。</p>
<ul>
<li>加密过程：(m^e) mod n=c，其中m为原信息，c为加密信息，n、e为公开密钥。</li>
<li>解密过程：(c^d) mod n=m，其中d为解密密钥。</li>
<li>解密密钥d的求解：(c^d) mod n=(((m^e) mod n)^d) mod n=((m<sup>e)</sup>d) mod n=(m^ed) mod n=m ①根据费马定理(m^φ(n)) mod n≡1，又1<sup>k≡1，所以(m</sup>k<em>φ(n)) mod n≡1，两边同乘以m得m</em>((m^k<em>φ(n)) mod n)≡1</em>m，化简(m^(k<em>φ(n)+1)) mod n≡m ②由①、②得ed=(k</em>φ(n)+1)，解得d=(k*φ(n)+1)/e。</li>
</ul>
<blockquote>
<p>费马定理：若p是素数，a与p互素，则a^(p-1）≡1 （mod p）</p>
</blockquote>
<p><strong>过程如下：</strong></p>
<ul>
<li>A：有一个公钥n、e。例如：3127、3。</li>
<li>B：有一个信息m。例如：89。</li>
<li>C：偷听者<br>
<strong>对A：</strong><br>
第一步：随机找两个质数p1、p2，一个奇数e。例如：53、59、3。<br>
第二步：计算n=p1<em>p2得到n，计算欧拉函数φ(n)=(p1-1)</em>(p2-1)得到φ(n)，计算钥匙d=(k<em>φ(n)+1)/e得到d。例如：53</em>59=3127、(53-1)<em>(59-1)=3016、(k</em>φ(n)+1)/e=(2*3016+1)/3=2011。<br>
第三步：发送n、e给大家知道    //n、e就是公钥也做锁，d就是n、e的钥匙。<br>
<strong>对C：</strong><br>
获得n、e<br>
<strong>对B：</strong><br>
第一步：获得n、e<br>
第二步：加密信息m，(m^e) mod n=c，获得加密信息c。例如：(89^3) mod 3127=1394。<br>
第三步：发送c给A<br>
<strong>对C：</strong></li>
</ul>
<ul>
<li>第一步：截获加密信息c</li>
<li>第二步：破解信息c，此时C只有n、e、c，只有把n分解质因数才能破解，而此分解很困难特别是当n很大的时候。<br>
<strong>对A：</strong><br>
第一步：收到加密信息c<br>
第二步：解密信息c，(c^d) mod n=m，获得信息m。例如：(1394^2011) mod 3127=89。完成</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[适配器模式和装饰器模式的区别]]></title>
        <id>https://guozixu2001.github.io/post/shi-pei-qi-yu-zhuang-shi-qi/</id>
        <link href="https://guozixu2001.github.io/post/shi-pei-qi-yu-zhuang-shi-qi/">
        </link>
        <updated>2022-06-02T15:25:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="区别">区别</h1>
<p>装饰器与适配器都有一个别名叫做<strong>包装模式(Wrapper)</strong>，它们看似都是起到包装一个类或对象的作用，但是使用它们的目的很不一一样。</p>
<ul>
<li>适配器模式的意义是要将一个接口转变成另一个接口，它是通过<strong>改变接口</strong>来达到重复使用的目的。</li>
<li>装饰器模式不是要改变被装饰对象的接口，而是恰恰要<strong>保持原有的接口</strong>，但是增强原有对象的功能，或者改变原有对象的处理方式而提升性能。所以这两个模式设计的目的是不同的。<br>
<strong>Note:</strong> 两者都是基于 delegation</li>
</ul>
<h2 id="通俗的理解两种模式">通俗的理解两种模式</h2>
<ul>
<li>适配器模式是网线的转接口，把网线的接口包装成 type-c</li>
<li>装饰器模式相当于，为了在奶茶中加料（烧仙草），创建了一个新的包装类（包装类即为烧仙草类）方便加料之后的计算。</li>
</ul>
<h3 id="装饰器模式代码">装饰器模式代码</h3>
<pre><code class="language-java">public class MyClass {
    public static void main(String args[]) {
        int totalCost = new Boba(new Coffee()).cost();
        System.out.println(totalCost);
    }
}

interface Beverage {
    public int cost();
}

class Coffee implements Beverage {
    private int price = 2;
    @Override
    public int cost() {
        return this.price; 
    }
    
}

class Boba implements Beverage {
    private int price = 1;
    private Beverage beverage;
    
    public Boba(Beverage beverage) {
        this.beverage = beverage;
    }
    
    @Override
    public int cost() {
        return this.price + beverage.cost();
    }
}
</code></pre>
<h3 id="适配器模式代码">适配器模式代码</h3>
<pre><code class="language-java">public class MyClass {
    public static void main(String args[]) {
        Computer computer = new Computer();
        computer.makeSounds(new Adapter(new Speaker()));
    }
}

class Speaker {
    public void makeSounds() {
        System.out.println(&quot;lalalla&quot;);
    }
}

class Adapter {
    private Speaker speaker;
    public Adapter(Speaker spkr) {
        this.speaker = spkr;
    }
    
    public void makeSounds() {
        speaker.makeSounds();
    }
}

class Computer {
    public void makeSounds(Adapter adapter) {
        adapter.makeSounds();
    }
}
</code></pre>
<h1 id="java-io-中的装饰器模式">Java IO 中的装饰器模式</h1>
<p>装饰器模式的作用就是赋予被装饰的类更多功能，在 java I/O 类库中有很多不同的功能组合情况，这些不同的功能组合都是使用了装饰器模式事项大的，下面以 <code>FilterInputStream</code> 为例介绍装饰器模式的使用。<br>
<code>InputeStream</code> 类就是以抽象组件存在的：而 <code>FileInputStream</code> 就是具体组件，它实现了抽象组件的所有接口；<code>FilterInputStream</code> 类无疑就是装饰角色，它实现了 <code>InputStream</code> 类的所有接口，并且持有 <code>InputStream</code> 的对象实例的引用；<br>
<code>BufferedInputStream</code> 是具体的装饰器实现者，它给 <code>InputStream</code> 类附加了功能，这个装饰器类的作用就是使得 <code>InputStream</code> 读取的数据保存在内存中，而提高读取的性能。与这个装饰器类有类似功能的还有 <code>LineNumberInputStream</code>（java 1.8 已经过期）类，它的作用就是提高行按行读取数据的功能，它们都是 <code>InputStream</code> 类增强了功能，或者提升了性能。</p>
<h1 id="java-io-中的适配器模式">Java IO 中的适配器模式</h1>
<p>适配器的作用就是将一个接口适配到另一个接口。在 JAVA 的 IO 类库中有很多这样的需求，如将字符串数据转变成字节数据保存到文件中，将字节数据转变成流数据等。下面以 <code>InputStreamReader</code> 和<code>OutputStreamWriter</code> 类为例介绍适配器模式。<br>
<code>InputStreamReader</code> 和 <code>OutputStreamWrite</code>r 分别继承 <code>Reader</code> 和 <code>Writer</code> 两个抽象类，但是要创建它们的对象必须在构造函数中传入一个 <code>InputStream</code> 和 <code>OutputStream</code> 的实例。<code>InputStreamReader</code> 和 <code>OutputStreamWriter</code><br>
也就是将 <code>InputStream</code> 和 <code>OutputStream</code> 适配到 <code>Reader</code> 和 <code>Writer</code> .</p>
<h1 id="复习一下适配器模式">复习一下适配器模式</h1>
<ul>
<li>target（目标接口）:所要转换的所期待的接口</li>
<li>Adaptee（源角色）：需要适配的类</li>
<li>Adapter（适配器）：将源角色适配成目标接口，一般持有源接口的引用（或者继承源接口），且实现目标接口</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式的简单总结]]></title>
        <id>https://guozixu2001.github.io/post/qian-tan-java-zhong-de-she-ji-mo-shi/</id>
        <link href="https://guozixu2001.github.io/post/qian-tan-java-zhong-de-she-ji-mo-shi/">
        </link>
        <updated>2022-06-01T09:28:22.000Z</updated>
        <content type="html"><![CDATA[<p>设计模式，很多人都会觉得这个概念很熟悉，会想到单例模式、工厂模式等等，但是似乎又说不出来什么，说不上它的核心思想和设计原则。其实我们的项目中，为了代码复用，增加可维护性，很多地方都用到了设计模式，它的思想和设计精髓贯穿每一个系统设计。<br>
今天整理了一下，发现也只不过用到了常用的几种设计模式，还有很多我闻所未闻，甚至连模式的名字都没有听过，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。在具体到每一个设计模式的实例之前，我觉得有必要先简单认识和了解一下什么是设计模式，先对这些概念有一个大概的印象，然后再深入下去。</p>
<h1 id="设计模式简介">设计模式简介</h1>
<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
<h1 id="设计模式基本要素">设计模式基本要素</h1>
<p>设计模式主要有四个基本要素：</p>
<ul>
<li>模式名称(pattern name)：一个助记名，它用以两个词来描述模式的问题、解决方案和效果。</li>
<li>问题(problem):描述了应该在何时使用模式。</li>
<li>解决方案(solution):描述了设计的组成成分，他们之间的相互关系及各自的职责和协助方式。</li>
<li>效果(consequendes):描述了应用的效果及使用模式应权衡的问题。</li>
</ul>
<h1 id="设计模式分类">设计模式分类</h1>
<p>设计模式主要分为三大类：</p>
<h2 id="创建型模式">创建型模式</h2>
<p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。主要有以下5种模式：</p>
<ul>
<li>工厂方法模式（Factory Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
<li>单例模式（Singleton Pattern）</li>
<li>建造者模式（Builder Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
</ul>
<h2 id="结构型模式">结构型模式</h2>
<p>用于描述如何将类或对象按某种布局组成更大的结构。<br>
主要有以下7种模式：</p>
<ul>
<li>适配器模式（Adapter Pattern）</li>
<li>装饰器模式（Decorator Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。<br>
主要有以下11种模式:</li>
<li>策略模式（Strategy Pattern）</li>
<li>模板方法模式（Template Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>迭代器模式（Iterator Pattern）</li>
<li>责任链模式（Chain of Responsibility Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>访问者模式（Visitor Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
</ul>
<h1 id="设计模式遵循原则">设计模式遵循原则</h1>
<p>设计模式遵循6大原则，分别为：</p>
<ul>
<li>开闭原则（Open Close Principle）：对扩展开放，对修改关闭。</li>
<li>里氏代换原则（Liskov Substitution Principle）：只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</li>
<li>依赖倒转原则（Dependence Inversion Principle）：这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。</li>
<li>接口隔离原则（Interface Segregation Principle）：使用多个隔离的接口来降低耦合度。</li>
<li>迪米特法则（最少知道原则）（Demeter Principle）:一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
<li>合成复用原则（Composite Reuse Principle）:原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SOLID原则]]></title>
        <id>https://guozixu2001.github.io/post/solid-yuan-ze/</id>
        <link href="https://guozixu2001.github.io/post/solid-yuan-ze/">
        </link>
        <updated>2022-05-25T15:53:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么需要solid原则">为什么需要SOLID原则？</h1>
<p>无论是软件系统设计，还是代码实现，遵循有效和明确的设计原则，都利于系统软件灵活可靠，安全快速的落地，更重要的是能灵活地应对需求，简化系统扩展和维护，避免无效的编码。</p>
<h1 id="单一职责srp">单一职责（SRP）</h1>
<blockquote>
<p>single reponsibility priciple</p>
</blockquote>
<h2 id="相关设计模式">相关设计模式</h2>
<p>面对违背单一职责原则的程序代码，我们可以利用外观模式，代理模式，桥接模式，适配器模式，命令模式对已有设计进行重构，实现多职责的分离。</p>
<h2 id="简单的应用场景">简单的应用场景</h2>
<p>只要做过项目，肯定要接触到用户、机构、角色管理这些模块，基本上使用的都是RBAC模型（Role-Based Access Control，基于角色的访问控制，通过分配和取消角色来完成用户权限的授予和取消，使动作主体（用户）与资源的行为（权限）分离），确实是一个很好的解决办法。我们这里要讲的是用户管理、修改用户的信息、增加机构（一个人属于多个机构）、增加角色等，用户有这么多的信息和行为要维护，我们就把这些写到一个接口中。<br>
<img src="https://guozixu2001.github.io//post-images/1654963348022.png" alt="" loading="lazy"><br>
但是这样的设计不是很好的设计，应该把用户的信息抽取成一个BO（Business Object，业务对象），把行为抽取成一个Biz（Business Logic，业务逻辑），按照这个思路对类图进行修正。<br>
<img src="https://guozixu2001.github.io//post-images/1654963398863.png" alt="" loading="lazy"><br>
以上把一个接口拆分成两个接口的动作，就符合单一职责原则：有且只有一个原因引起类的变更。</p>
<h1 id="开闭原则ocp">开闭原则（OCP）</h1>
<p>开闭原则 (OCP) 英文全称为 Open-Closed Principle，基本定义是软件中的对象（类，模块，函数等）应该对于扩展是开放的，但是对于修改是封闭的。这里的对扩展开放表示这添加新的代码，就可以让程序行为扩展来满足需求的变化；对修改封闭表示在扩展程序行为时不要修改已有的代码，进而避免影响原有的功能。</p>
<h2 id="应用场景">应用场景</h2>
<p>有一个用于图表显示的 Display 类，它能绘制各种类型的图表，比如饼状图，柱状图等；而需要绘制特定图表时，都强依赖了对应类型的图表，Display 类的内部实现如下：</p>
<pre><code class="language-java">public void display(String type) {
    if (type.equals(&quot;pie&quot;)) {  
      PieChart chart = new PieChart();  
      chart.display();  
    }  else if (type.equals(&quot;bar&quot;)) {  
      BarChart chart = new BarChart();  
      chart.display();  
    } 
}
</code></pre>
<p>基于上述的代码，如果需要新增一个图表，比如折线图 LineChart ，就要修改 Display 类的 display() 方法，增加新增的判断逻辑，很显然这样的做法违反开闭原则。而让类的实现符合开闭原则的方式就是引入抽象图表类 AbstractChart，作为其他图表的基类，让 Display 依赖这个抽象图表类 AbstractChart，然后通过 Display 决定使用哪种具体的图表类，实现代码变成了这样：</p>
<pre><code class="language-java">private Abstractchart chart;

public void display() {
    chart.display();  
}
</code></pre>
<p>现在我们需要新增折线图显示，在客户端向 Display 中注入一个 LineChart 对象即可，无须修改现有类库的源代码。</p>
<h2 id="相关的设计模式">相关的设计模式</h2>
<p>可以用到的设计模式有很多，比如工厂模式，观察者模式，模板方法模式，策略模式，组合模式，使用相关设计模式的关键点就是识别出最有可能变化和扩展的部分，然后构造抽象来隔离这些变化。</p>
<h1 id="里式替换原则-lsp">里式替换原则 (LSP)</h1>
<h2 id="基本概念">基本概念</h2>
<p>里式替换原则 (LSP) 英文全称为 Liskov Substitution Principle，基本定义为：在不影响程序正确性的基础上，所有使用基类的地方都能<strong>使用其子类的对象</strong>来替换。这里提到的基类和子类说的就是具有继承关系的两类对象，当我们传递一个子类型对象时，需要保证程序不会改变任何原基类的行为和状态，程序能正常运作。</p>
<h2 id="原则">原则</h2>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li>
<li>子类可以有自己的个性</li>
<li>子类型中重写的方法必须有相同或子类型的<strong>返回值</strong>或者符合co-variant的参数</li>
<li>子类型中重写的方法必须使用同样类型的<strong>参数</strong>或者符合contra-variant的参数(此种情况Java目<br>
前按照重载overload处理)</li>
<li>子类型重写的方法不能有额外的异常</li>
</ul>
<h1 id="接口隔离原则-isp">接口隔离原则 (ISP)</h1>
<h2 id="基本概念-2">基本概念</h2>
<p>接口隔离原则 (ISP) 英文全称为 Interface Segregation Principle，基本定义：客户端不应该依赖那些它不需要的接口。客户端应该只依赖它实际使用的方法，因为如果一个接口具备了若干个方法，那就意味着它的实现类都要实现所有接口方法，从代码结构上就十分臃肿</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何正确的从List中删除元素(Java)？]]></title>
        <id>https://guozixu2001.github.io/post/ru-he-zheng-que-de-cong-list-zhong-shan-chu-yuan-su-java/</id>
        <link href="https://guozixu2001.github.io/post/ru-he-zheng-que-de-cong-list-zhong-shan-chu-yuan-su-java/">
        </link>
        <updated>2022-05-22T12:39:58.000Z</updated>
        <content type="html"><![CDATA[<p>遍历删除List中符合条件的元素主要有以下几种方法：</p>
<p>1.普通for循环 2.增强for循环 foreach 3.迭代器iterator 4.removeIf 和 方法引用 (一行代码搞定) 其中使用普通for循环容易造成遗漏元素的问题，增强for循环foreach会报java.util.ConcurrentModificationException并发修改异常。<br>
所以推荐使用迭代器iterator，或者JDK1.8以上使用lambda表达式进行List的遍历删除元素操作。</p>
<p>以下是上述几种方法的具体分析：</p>
<h1 id="普通for循环">普通for循环</h1>
<pre><code class="language-java">/** 
 * 普通for循环遍历删除元素
 */  
    List&lt;Student&gt; students = this.getStudents();  
    for (int i=0; i&lt;students.size(); i++) {  
        if (students.get(i).getId()%3 == 0) {  
            Student student = students.get(i);  
            students.remove(student);  
        }  
    }
</code></pre>
<p>由于在循环中删除元素后，list的索引会自动变化，list.size()获取到的list长度也会实时更新，所以会造成漏掉被删除元素后一个索引的元素。</p>
<p>比如循环到第2个元素时你把它删了，接下来去访问第3个元素，实际上访问到的是原来list的第4个元素，因为原来的第3个元素变成了现在的第2个元素。这样就造成了元素的遗漏。</p>
<h1 id="增强for循环-foreach">增强for循环 foreach</h1>
<pre><code class="language-java">/**
 * 增强for循环遍历删除元素
 */
    List&lt;Student&gt; students = this.getStudents();  
    for (Student stu : students) {  
        if (stu.getId() == 2)   
            students.remove(stu);  
    }
</code></pre>
<p>使用foreach遍历循环删除符合条件的元素，不会出现普通for循环的遗漏元素问题，但是会产生  <code>java.util.ConcurrentModificationException</code> 并发修改异常的错误。</p>
<p>报 <code>ConcurrentModificationException</code> 错误的原因：</p>
<p>先来看一下JDK源码中ArrayList的remove源码是怎么实现的：</p>
<pre><code class="language-java">public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index &lt; size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index &lt; size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }
</code></pre>
<p>一般情况下程序的执行路径会走到else路径下最终调用fastRemove方法：</p>
<pre><code class="language-java">private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }
</code></pre>
<p>在fastRemove方法中，可以看到第2行把modCount变量的值加一，但在ArrayList返回的迭代器会做迭代器内部的修改次数检查：</p>
<pre><code class="language-java">final void checkForComodification() {
         if (modCount != expectedModCount)
             throw new ConcurrentModificationException();
     }
</code></pre>
<p>而foreach写法是对实际的Iterable、hasNext、next方法的简写，因为上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。</p>
<p>要避免这种情况的出现则在使用迭代器迭代时（显式或for-each的隐式）不要使用List的remove，改为用Iterator的remove即可。</p>
<h1 id="迭代器iterator">迭代器iterator</h1>
<pre><code class="language-java">/**
 *  迭代器iterator
 */
     List&lt;Student&gt; students = this.getStudents();  
     System.out.println(students);  
     Iterator&lt;Student&gt; iterator = students.iterator();  
     while (iterator .hasNext()) {  
         Student student = iterator .next();  
         if (iterator.getId() % 2 == 0)  
             iterator.remove();//这里要使用Iterator的remove方法移除当前对象，如果使用List的remove方法，则同样会出现ConcurrentModificationException  
     }
</code></pre>
<p>由上述foreach报错的原因，注意要使用迭代器的remove方法，而不是List的remove方法。</p>
<h1 id="removeif-和-方法引用">removeIf 和 方法引用</h1>
<p>在JDK1.8中，Collection以及其子类新加入了removeIf方法，作用是按照一定规则过滤集合中的元素。</p>
<p>方法引用是也是JDK1.8的新特性之一。方法引用通过方法的名字来指向一个方法，使用一对冒号 :: 来完成对方法的调用，可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<p>使用removeIf和方法引用删除List中符合条件的元素：</p>
<pre><code class="language-java">List&lt;String&gt; urls = this.getUrls();  

// 使用方法引用删除urls中值为&quot;null&quot;的元素
urls.removeIf(&quot;null&quot;::equals);
</code></pre>
<p>作为removeIf的条件，为true时就删除元素。</p>
<p>使用removeIf 和 方法引用，可以将原本需要七八行的代码，缩减到一行即可完成，使代码的构造更紧凑简洁，减少冗余代码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HIT软件构造-面向复用的软件构造技术]]></title>
        <id>https://guozixu2001.github.io/post/hit-ruan-jian-gou-zao-mian-xiang-fu-yong-de-ruan-jian-gou-zao-ji-zhu/</id>
        <link href="https://guozixu2001.github.io/post/hit-ruan-jian-gou-zao-mian-xiang-fu-yong-de-ruan-jian-gou-zao-ji-zhu/">
        </link>
        <updated>2022-05-20T14:58:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="design-reuseable-class">Design reuseable class</h1>
<p>LSP原则<br>
子类型多态：用统一的方式处理不同类型的对象<br>
Animal a = new Animal();<br>
Animal c1 = new Cat();</p>
<ul>
<li>子类型方法参数：<strong>逆变</strong>，返回值：<strong>协变</strong></li>
<li>子类型中重写的方法不能抛出额外的异常</li>
<li>precondition不能强化</li>
<li>post-condition不能弱化</li>
<li>保持或者更强不变量</li>
</ul>
<pre><code class="language-java">class T {
    Object a() {}
}
class S extends T {
    @Override
    String a() {}    
}
class T {
    void b() throws Throwable {}
}
class S extends T {
    @Override
    void b() throws IOException {}
}
</code></pre>
<p><strong>委托与继承的区别</strong></p>
<ul>
<li>继承：继承一个基类，添加新的方法或者重写原来的方法来实现某个功能</li>
<li>委托：将某个功能的一部分直接委托给其它对象<br>
委托能办到的，继承似乎都能办到，那么为什么不直接使用继承呢？</li>
</ul>
<p>譬如，如果子类只需要复用父类的一小部分方法，完全可以不需要继承，而是通过委托机制来实现，从而避免继承大量无用的方法</p>
<p><strong>合成复用原则(CRP)</strong><br>
内容：</p>
<p>类应该通过它们的组合（通过包含实现所需功能的其他类的实例）而不是从基类或父类继承来实现多态的行为和代码重用<br>
组合一个对象可以做什么(has_a 或 use_a)比扩展它是什么(is_a)更好<br>
也就是说，组合要优先于继承（组合式委托的一种形式）</p>
<p>注意：委托发生在对象的层面，而继承发生在类的层面</p>
<p>那么为什么在对象层面更好呢？举个例子：</p>
<p>Employee类有一个方法用于计算奖金：</p>
<pre><code class="language-java">class Employee {
    Money computeBonus() {... // default computation}
}
</code></pre>
<p>它会有很多不同的子类，例如Manager,Programmer,Secretary，那么计算它们的奖金的时候肯定要重写方法：</p>
<pre><code class="language-java">class Manager extends Employee {
    @Override
    Money computeBonus() {... // special computation}
}
</code></pre>
<p>如果不同类型的manager需要不同的计算方式，那么就有需要引入子类：</p>
<pre><code>class SeniorManager extends Manager {
    @Override
    Money computeBonus(){... // more special computation}
}
</code></pre>
<p>如果要将某个人从Manager提升为SeniorManager，那么该怎么处理呢？</p>
<p>核心问题在于：每个Employee对象的奖金计算方法都不同，这在对象层面而不是类层面</p>
<p>显然，委托机制要更好，使用 CRP 原则的一种实现可以是：</p>
<pre><code class="language-java">class Manager {
    ManagerBonusCalculator mbc = new ManagerBonusCalculator();
    Money computeBonus() {
        return mbc.computeBonus();
    }
}

class ManagerBonusCalculator {
    Maney computeBonus {... // special computation}
}
```Cat c2 = new Cat();
// a can be replaced by c1 and c2
</code></pre>
<p><strong>七点原则：</strong></p>
<ul>
<li>子类必须完全实现父类的方法（包括抽象类所有未实现的方法）</li>
<li>但是，子类可以增加方法（猫既可以叫，也可以吃鱼）</li>
<li>子类型方法参数：<strong>逆变</strong>，返回值：<strong>协变</strong></li>
<li>子类型中重写的方法不能抛出额外的异常</li>
<li>precondition不能强化</li>
<li>post-condition不能弱化</li>
<li>保持或者更强不变量</li>
</ul>
<pre><code class="language-java">class T {
    Object a() {}
}
class S extends T {
    @Override
    String a() {}    
}
class T {
    void b() throws Throwable {}
}
class S extends T {
    @Override
    void b() throws IOException {}
}
</code></pre>
<p><strong>委托与继承的区别</strong></p>
<ul>
<li>继承：继承一个基类，添加新的方法或者重写原来的方法来实现某个功能</li>
<li>委托：将某个功能的一部分直接委托给其它对象<br>
委托能办到的，继承似乎都能办到，那么为什么不直接使用继承呢？</li>
</ul>
<p>譬如，如果子类只需要复用父类的一小部分方法，完全可以不需要继承，而是通过委托机制来实现，从而避免继承大量无用的方法</p>
<p><strong>合成复用原则(CRP)</strong><br>
内容：</p>
<p>类应该通过它们的组合（通过包含实现所需功能的其他类的实例）而不是从基类或父类继承来实现多态的行为和代码重用<br>
组合一个对象可以做什么(has_a 或 use_a)比扩展它是什么(is_a)更好<br>
也就是说，组合要优先于继承（组合式委托的一种形式）</p>
<p>注意：委托发生在对象的层面，而继承发生在类的层面</p>
<p>那么为什么在对象层面更好呢？举个例子：</p>
<p>Employee类有一个方法用于计算奖金：</p>
<pre><code class="language-java">class Employee {
    Money computeBonus() {... // default computation}
}
</code></pre>
<p>它会有很多不同的子类，例如Manager,Programmer,Secretary，那么计算它们的奖金的时候肯定要重写方法：</p>
<pre><code class="language-java">class Manager extends Employee {
    @Override
    Money computeBonus() {... // special computation}
}
</code></pre>
<p>如果不同类型的manager需要不同的计算方式，那么就有需要引入子类：</p>
<pre><code class="language-java">class SeniorManager extends Manager {
    @Override
    Money computeBonus(){... // more special computation}
}
</code></pre>
<p>如果要将某个人从Manager提升为SeniorManager，那么该怎么处理呢？</p>
<p>核心问题在于：每个Employee对象的奖金计算方法都不同，这在对象层面而不是类层面</p>
<p>显然，委托机制要更好，使用 CRP 原则的一种实现可以是：</p>
<pre><code class="language-java">class Manager {
    ManagerBonusCalculator mbc = new ManagerBonusCalculator();
    Money computeBonus() {
        return mbc.computeBonus();
    }
}

class ManagerBonusCalculator {
    Maney computeBonus {... // special computation}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HIT软件构造-Equality in OOP and ADT]]></title>
        <id>https://guozixu2001.github.io/post/hit-ruan-jian-gou-zao-equality-in-oop-and-adt/</id>
        <link href="https://guozixu2001.github.io/post/hit-ruan-jian-gou-zao-equality-in-oop-and-adt/">
        </link>
        <updated>2022-05-15T15:44:47.000Z</updated>
        <content type="html"><![CDATA[<p>在现实物理世界中，任何对象都是不相等的但是对于人类语言，或者对于数学世界，完全可以有很多相同的东西，例如√9 和 3 表现了相等的数值，我们完全可以认为两者是相同的那么在软件世界中，Java 的==和equals()有什么区别？<br>
在很多场景下，需要判定两个对象是否 “相等”，例如：判断某个Collection中是否包含某个特定元素，这时该依据什么来判定？如何为自定义的 ADT 正确实现equals()？<br>
本文就是要解决上述问题<br>
先说明等价关系，它指对于关系 E ⊆ T x T ，满足：自反性: E(t,t) ∀ t ∈ T对称性: E(t,u) ⇒ E(u,t)传递性: E(t,u) ∧ E(u,v) ⇒ E(t,v)严格来说，我们可以从三个角度定义相等：利用等价关系，我们说 a 与 b 相等，当且仅当 E(a,b)利用抽象函数，AF: R → A ，它将具体的表示数据映射到了抽象值，那么当且仅当 AF(a)=AF(b)时，我们说 a 与 b 相等站在外部观察者角度：对两个对象调用任何相同的操作，都会得到相同的结果，则认为这两个对象相等举例：<br>
Duration这里有一个不可变ADT的例子：</p>
<pre><code class="language-java">public class Duration {
    private final int mins;
    private final int secs;
    // Rep invariant:
    //    mins &gt;= 0, secs &gt;= 0
    // Abstraction function:
    //    AF(min, secs) = the span of time of mins minutes and secs seconds

    /** Make a duration lasting for m minutes and s seconds. */
    public Duration(int m, int s) {
        mins = m; secs = s;
    }
    /** @return length of this duration in seconds */
    public long getLength() {
        return mins*60 + secs;
    }
}
</code></pre>
<p>那么对于下面的 4 个对象：</p>
<pre><code class="language-java">Duration d1 = new Duration (1, 2);
Duration d2 = new Duration (1, 3);
Duration d3 = new Duration (0, 62);
Duration d4 = new Duration (1, 2);
</code></pre>
<p>从抽象函数的角度来看，表示域为 {mins, secs}，而抽象域为两者计算的时间{mins×60 + secs}，d1,d3,d4算出来的时间相等，即映射到了相同的抽象域，我们可以认为这 3 个对象相等站在外部观察者角度，这个类唯一的观察器是getLength()，d1,d3,d4调用返回的结果总是相等的，所以也可以认为这 3 个对象相等== vs. equals()和很多其他语言一样，Java有两种判断相等的操作—— == 和 equals() 。<mark>比较的是引用。它比较的是引用等价性(referential equality)。如果两个引用指向同一块存储区域，那它们就是</mark>的，例如我们之前提到过的快照图，<mark>就意味着它们的箭头指向同一个对象equals()操作比较的是对象的内容，它比较的是对象等价性(object equality)作为对比，这里列出来了几个语言中的相等操作：referential equalityobject equalityJava</mark>equals()Objective C<mark>isEqual:C#<mark>Equals()Pythonis</mark>Javascript</mark>n/a注意到<mark>在 Java 和 Python 中的意义正好相反，别被这个弄混了那么两者该怎么使用呢？对于基本数据类型，使用</mark>判定相等对于对象数据类型，应总是使用equals()判断相等，因为如果判断逻辑是内存地址相等，则不需要重写Object.equals()，此时equals()与==是等价的，如果有特定的判断逻辑，则需要根据逻辑重写Object.equals重写equals()equals() 是在 Object 中定义的，它的默认实现方式如下：public class Object {<br>
...<br>
public boolean equals(Object that) {<br>
return this == that;<br>
}<br>
}<br>
可以看到， equals() 在Object中的实现方法就是引用相等，对于不可变类型的对象来说，这几乎总是错的，所以需要根据需求重写equals()例如，我们可以重写前面Duration中的equals()方法：@Override<br>
public boolean equals(Object that) {<br>
return that instanceof Duration &amp;&amp; this.sameValue((Duration)that);<br>
}</p>
<p>// returns true iff this and that represent the same abstract value<br>
private boolean sameValue(Duration that) {<br>
return this.getLength() == that.getLength();<br>
}<br>
它首先判断了传入的that是 Duration，然后调用sameValue() 去判断它们的值是否相等。表达式 (Duration)that 是一个类型转换操作，它告诉编译器 that指向的是一个 Duration对象注意这里用到了instanceof它用于判断对象是不是某个特定类型（或其子类型）对象契约(Object contract)由于Object的规约实在太重要了，我们有时也称它为对象契约(the Object Contract)当重写equals()时，需要遵守这些规定：equals() 必须定义一个等价关系，即一个满足自反、对称和传递关系equals() 必须是确定的，即连续重复的进行相等操作，结果应该相同对于不是null的引用x， x.equals(null) 应该返回false如果两个对象使用 equals 操作后结果为真，那么它们各自的hashCode 操作的结果也应该相同破坏等价关系我们必须保证equals()构建出一个满足自反性、对称性、传递性的等价关系如果没有满足，那么与相等相关的操作（例如集合、搜索）将变得不可预测例如，我们肯定不希望a等于b但是后来发现b不等于a，这都是非常隐秘的 bug比如假设我们希望在判断 Duration 相等的时候允许一些误差，因为不同的电脑同步的时间可能会有不同：</p>
<pre><code class="language-java">@Override
public boolean equals(Object that) {
    return that instanceof Duration &amp;&amp; this.sameValue((Duration)that);
}

private static final int CLOCK_SKEW = 5; // seconds

// returns true iff this and that represent the same abstract value within a clock-skew tolerance
private boolean sameValue(Duration that) {
    return Math.abs(this.getLength() - that.getLength()) &lt;= CLOCK_SKEW;
}
</code></pre>
<p>创建如下对象：Duration d_0_60 = new Duration(0, 60);</p>
<pre><code class="language-java">Duration d_1_00 = new Duration(1, 0);
Duration d_0_57 = new Duration(0, 57);
Duration d_1_03 = new Duration(1, 3);
</code></pre>
<p>很显然，d_0_57.equals(d_1_03)的返回值为false，违反了传递性破坏哈希表(Hash Tables)一个哈希表表示的是一种映射：从键值映射到值的抽象数据类型。哈希表提供了常数级别的查找，所以它的性能非常棒哈希表是怎么工作的呢？它包含了一个初始化的数组，其大小是我们设计好的。当一个键值对准备插入时，我们计算这个键的hashcode，产生一个索引，它在我们数组大小的范围内（例如使用取模运算），然后将值插入到数组索引对应的位置哈希表的一个基本不变量(RI)就是键的位置必须由hashcode确定Hashcodes 最好被设计为键计算后的索引平滑、均匀的分布在所有范围内但是偶尔也会发生冲突，例如两个键计算出了同样的索引，因此哈希表通常存储的是一个键值对的列表而非一个单个的值，这通常被称为哈希桶(hash bucket)而在 Java 中，键值对就是一个有着两个域的对象。当插入时，在计算出的索引位置插入一个键值对，当查找时，先根据键哈希出对应的索引，然后在索引对应的位置找到键值对列表，最后在这个列表中查找你的键，如图：<img src="https://pica.zhimg.com/v2-11c11c59371e7e0a233ebaa567214f03_720w.png?source=d16d100b" data-caption="" data-size="normal" class="content_image">这就是为什么Object的规约要求相等的对象必须有同样的 hashcode，如果两个相等的对象 hashcode 不同，那么它们存储的时候位置也就不一样——如果你存入了一个对象，然后查找一个相等的对象，就可能在错误的索引处进行查找，也就会得到错误的结果重写hashCode()Object.hashCode默认返回的是对象的地址，如果我们重写了equals()方法，那么我们就违反了对象契约，所以也应该同步重写hashCode()方法最简单的重写hashCode()方法就是让所有的对象的 hashcode 为同一常量，但是由上面哈希表实现原理讲到的，这样会大大降低哈希表的效率一个比较通用的办法是通过equals()中用到的所有信息的 hashcode 组合出新的 hashcode例如前面的Duration可以这样写：@Override<br>
public int hashCode() {<br>
return (int) getLength();<br>
}<br>
只要满足了相等的对象产生相同的 hashcode，无论这个 hashcode 是如何实现的，代码就总会是正确的举例：phoneNumber一个电话号码类的hashCode()方法，它可以这样写：</p>
<pre><code class="language-java">public final class PhoneNumber {
    private final short areaCode;
	private final short prefix;
	private final short lineNumber;
    
	@Override
	public int hashCode() {
		int result = 17; // Nonzero is good
		result = 31 * result + areaCode; // Constant must be odd
		result = 31 * result + prefix; // &quot; &quot; &quot; &quot;
		result = 31 * result + lineNumber; // &quot; &quot; &quot; &quot;
		return result;
	}
	...
}
//也有更聪明的写法：
public final class PhoneNumber {
	private final short areaCode;
	private final short prefix;
	private final short lineNumber;
	@Override
	public int hashCode() {
		short[] hashArray = {areaCode, prefix, lineNumber};
		return Arrays.hashCode(hashArray);
	}
	...
}
</code></pre>
<p>可变(mutable)类型的相等前面讨论的都是不可变类型，那么可变类型对象会是怎样呢？回忆之前我们对于相等的定义，即它们不能被使用者观察出来不同。而对于可变对象来说，它们多了一种新的可能：通过在观察前调用变值器，我们可以改变其内部的状态，从而观察出不同的结果所以重新定义两种相等：观察等价性：两个对象在不改变各自状态的前提下不能被区分。例如，只调用观察器、生产器、构造器时行为等价性：调用对象的任何方法都展现一致的结果对于可变类型来说，往往更倾向于实现严格的观察等价性，例如 Java 中的两个List包含相同顺序的元素，则equals()返回true观察等价性的缺陷但是，观察等价性可能会带来隐秘的 bug，甚至破坏表示不变量(RI)，比如我们现在有一个 List，然后我们将其存入一个 Set：</p>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add(&quot;a&quot;);

Set&lt;List&lt;String&gt;&gt; set = new HashSet&lt;List&lt;String&gt;&gt;();
set.add(list);
</code></pre>
<p><img src="https://pic1.zhimg.com/v2-56f0d2dd0a10a4f5d69879ed6f6c281c_720w.png?source=d16d100b" data-caption="" data-size="normal" class="content_image">我们可以检查这个集合是否包含我们存入的列表：set.contains(list) → true<br>
但是如果我们修改这个列表：list.add(&quot;goodbye&quot;);<br>
<img src="https://pic1.zhimg.com/v2-98df6d0e45c4a9b5bac31989ca3d740b_720w.png?source=d16d100b" data-caption="" data-size="normal" class="content_image">它似乎就不在集合中了！<code>set.contains(list) → false</code><br>
更糟糕的是：当我们用迭代器遍历这个集合时，我们会发现集合存在，但是<code>contains()</code> 说它不存在！</p>
<pre><code class="language-java">for (List&lt;String&gt; l : set) { 
    set.contains(l) → false! 
}
</code></pre>
<p>如果一个集合的迭代器和contains()都互相冲突，显然这个集合已经被破坏了原因分析我们知道 List<String> 是一个可变对象，而在 Java 对可变对象的实现中，操作通常都会影响 equals() 和 hashCode()的结果，所以列表第一次放入 HashSet的时候，它是存储在这时 hashCode() 对应的索引位置后来列表发生了改变，计算 hashCode() 会得到不一样的结果，但是 HashSet 并没有更新其在哈希桶中的位置，所以我们调用contains时候使用的新的hashcode来查找，当然就找不到了当 equals() 和 hashCode() 的结果可能被可变影响是，哈希表的表示不变性就会遭到破坏从这个例子我们可以看到，对于可变类型最好使用行为等价性，也就是说指向同样内存空间的对象才相等，但是 Java 并没有采用这种设计自动装箱(Autoboxing)我们之前提到过 Java 的原始类型和它对应的包装类型，例如int和Integer，包装类型的equals()比较的是值相等：</p>
<pre><code class="language-java">Integer x = new Integer(3);
Integer y = new Integer(3);
x.equals(y) → true
</code></pre>
<p>但是这里会有一个隐秘的问题，== 被重载了，对于 Integer这样的类型， == 判断的是引用相等：x == y // returns false<br>
对于基本类型int，==判断的是行为相等：(int)x == (int)y // returns true<br>
所以，并不能随意将Integer和int互换Java 会自动对int和Integer进行转换（自动装箱），这也会导致 bug，思考下面的代码：</p>
<pre><code class="language-java">Map&lt;String, Integer&gt; a = new HashMap(), b = new HashMap();
a.put(&quot;c&quot;, 130); // put ints into the map
b.put(&quot;c&quot;, 130);
a.get(&quot;c&quot;) == b.get(&quot;c&quot;) → false
</code></pre>
<p>放入Map时，会自动将int 130转为Integer而取出来的时候又是Integer类型，而对Integer类型的<mark>时引用相等的判断，所以用</mark>比较会返回false由于 Java 的常量池，又会导致以下结果：<img src="https://pic3.zhimg.com/v2-1fcb87e42bccc7a1298dd26e7e7d72e3_720w.png?source=d16d100b" data-caption="" data-size="normal" class="content_image">总结本文详细阐述了 ADT 中“相等”这个概念，应该注意以下要求：equals()应该满足等价关系（自反、对称、传递）equals()必须和哈希值保持一致，以便让使用哈希表的数据结构正常工作抽象函数是不可变类型相等的比较基础引用等价性是可变类型的比较基础最后，还是用以下三点结束本文：Safe from bugs. 正确地实现equals()和hashCode()对于collection类型用很重要（例如集合和映射），实现不可变类型时一定要重写这两个方法Easy to understand. 使用者在阅读规约后会期望我们的 ADT 实现合理的相等操作Ready for change. 为不可变类型实现的相等操作会把引用相等和抽象值相等分离，帮助避开隐秘的 bug</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HIT软件构造复习（1、2章）]]></title>
        <id>https://guozixu2001.github.io/post/hit-ruan-jian-gou-zao-fu-xi/</id>
        <link href="https://guozixu2001.github.io/post/hit-ruan-jian-gou-zao-fu-xi/">
        </link>
        <updated>2022-05-06T09:47:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="multi-dimensional-software-views软件构造中的多维视图">Multi-dimensional software views（软件构造中的多维视图）</h1>
<ul>
<li>
<p>Moment维度关注于程序在某一时刻的表现，而Period关注的是程序在一段时间内的表现。</p>
</li>
<li>
<p>Build-time维度关注程序还未被投入运行，编码阶段的表现，而Run-time维度更关注于程序运行时的表现；</p>
</li>
</ul>
<p><strong>Note:</strong></p>
<p>code-level view: functions \classes\methods\interfaces(代码逻辑组织）</p>
<p>component-level view: file \directories\packages\libraries (代码物理组织）</p>
<p>Static linking :库被拷贝进代码形成整体，执行的时候无需提供库文件（build time）<br>
runtime views（runtime就是运行，程序被载入目标机器，开始执行。）</p>
<p>以下是在各种视图（views）中的含义<br>
code-level ：逻辑实体在内存中如何呈现？（in-memory states）<br>
component-level ：物理实体在物理硬件环境中如何呈现？（physical environment）<br>
moment：逻辑/物理实体在内存/硬件中特定时刻的形态。<br>
period ：逻辑/物理实体在内存和/硬件中随时间如何变化。<br>
dynamic linking :动态链接</p>
<h1 id="视图之间的联系">视图之间的联系</h1>
<p>①从无到有，写出了代码，就进入了Build-time维度，开始只是单个的没有任何联系的代码文件，所以是在moment+Code-level维度；</p>
<p>②此时随着时间的推移，代码删删改改，就属于Period+Code-level了，而代码越写越多成为了一个包，甚至形成了一个库，于是就属于moment+Component-level维度了；</p>
<p>③但是随着时间的推移，库文件由于需求的变化发生了变化，所以就属于Period+Component-level；</p>
<p>④代码写好了，投入运行，进入Run-time维度，观察的如果是某一句代码的执行后结果，那就是moment+Code-level维度，但如果看的是代码执行的轨迹，那就是Period+Code-level维度，而如果看的是一个库文件的连接情况等，那就是moment+Component-level维度了；</p>
<p>⑤如果看的是线程或进程的执行过程，也就是通过日志等手段查看一段时间内系统都做了什么事情，那么就是Period+Component-level了。</p>
<h1 id="quality-objectives-of-software-construction外部质量与内部质量">Quality Objectives of Software Construction（外部质量与内部质量）</h1>
<p>外部质量因素影响用户，内部质量因素影响软件本身和它的开发者，外部质量取决于内部质量。</p>
<p><strong>外部质量的具体方面：</strong><br>
（1）正确性（Correctness）：至高无上的质量指标，按照预先定义的“规约”执行。一个可用的软件一定是正确的，所以首要保证软件的正确性，其他的都可以做妥协、让步，但只有这一项不可妥协。<br>
（2）健壮性（Robustness）:是对正确性的补充，即在出现“规约”定义之外的情形的时候，软件要做出恰当的反应，通俗地说就是出现异常时不要“崩溃”。<br>
但软件的“正常”与“异常”是主观而非客观的，所谓的“异常”，取决于spec的范畴，那些未被“规约”覆盖的情况即为“异常情况”。<br>
（3）可扩展性（Extendibility）<br>
（4）可复用性（Reusability）<br>
（5）兼容性（Compatibility）<br>
（6）效率（Efficiency）<br>
（7）可移植性（Portability）<br>
（8）易用性（Easy of use）<br>
（9）功能性（Functionality）</p>
<p><strong>折中处理：</strong></p>
<p>①正确的软件开发过程中，开发者应该将不同质量因素之间如何做出折中的设计决策和标准明确的写下来；</p>
<p>②当某一项满足的足够好的时候有可能其他项的表现极差，此时需要做权衡，使得各部分的表现都较好，在某些特定要求下也可以放弃优化其他项而做到某一项的极致；</p>
<p>③虽然需要折中，但“正确性”绝不能与其他质量因素折中。</p>
<p><strong>五个关键的质量指标：</strong></p>
<ul>
<li>Elegant and beautiful code：代码要容易理解，通过统一变量/方法的命名标准、代码的风格、注释、包组织结构、必要时重构代码等方式让代码尽可能的容易理解。</li>
<li>Design for/with reuse：ADT/OOP、接口、继承(Overload、Override)、多态、泛型、框架等技术可用于提高代码的可复用性。</li>
<li>Low complexity：当复杂度较低的时候，代码就容易被扩展新的功能，所以要高内聚低耦合，遵从SOLID原则、OO设计模式、使用VCS控制代码版本</li>
<li>Robustness and correctness：使用测试驱动的开发、异常处理、Assertion机制、防御式编程等技术保证程序的健壮性和正确性。</li>
<li>Performance and efficiency：使用设计模式、并行/多线程等技术提升性能。</li>
</ul>
<h1 id="软件测试与测试优先编程">软件测试与测试优先编程</h1>
<p><strong>测试：</strong><br>
在规定的条件下对程序进行操作，以发现程序错误，衡量软件品质，并对其是否能满足设计要求进行评估的过程。</p>
<p>①测试跟其他活动的目标相反：破坏、证错、“负能量”，即我们希望发现“错误”，要转变心态，用“让其出错”和“尽快出错”作为写高质量代码的日常法宝；</p>
<p>②要认识到即使是再好的测试也不能保证程序里不存在错误</p>
<p><strong>测试用例：</strong></p>
<p>测试用例 = 输入+执行条件+结果</p>
<p>最主要的方法——单元测试：针对软件的最小单元模型开展测试，隔离各个模块，容易定位错误和调试。</p>
<p>基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。</p>
<p>此外还要注意边界值分析方法的补充，即在进行等价类划分的时候，需要把边界也作为等价类之一加入考虑。</p>
<p><strong>覆盖度：</strong></p>
<ul>
<li>
<p>代码覆盖度<br>
基于代码的测试覆盖评测测试过程中已经执行的代码的多少，与之相对的是要执行的剩余代码的多少。</p>
</li>
<li>
<p>输入空间覆盖度<br>
参照模块的规格说明，测试用例占总输入空间的比例。</p>
</li>
</ul>
<p><strong>效率：</strong><br>
成果（测试结果）/资源（测试时间空间）</p>
<p>代码覆盖度越低，测试越不充分，但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高。</p>
<p>测试效果：路径覆盖 &gt; 分支覆盖 &gt; 语句覆盖</p>
<p>测试难度：路径覆盖 &gt; 分支覆盖 &gt; 语句覆盖</p>
<h2 id="两类测试">两类测试</h2>
<ul>
<li>黑盒测试：黑盒测试：用于检查代码的功能，不关心内部实现细节。检查程序是否符合规约</li>
<li>白盒测试：要考虑内部实现细节，根据程序执行路径设计测试用例。一般比较早执行</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java: pass-by-value or pass-by-reference?]]></title>
        <id>https://guozixu2001.github.io/post/java-zhong-de-han-shu-fan-hui-zhi-shi-lvaluezuo-zhi-yin-yong-ma/</id>
        <link href="https://guozixu2001.github.io/post/java-zhong-de-han-shu-fan-hui-zhi-shi-lvaluezuo-zhi-yin-yong-ma/">
        </link>
        <updated>2022-05-02T10:18:57.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.javadude.com/articles/passbyvalue.htm">REPOST:Java is Pass-by-Value, Dammit! </a><br>
<h1 id="introduction">Introduction</h1></p>
<p>I finally decided to write up a little something about Java&rsquo;s parameter passing. I&rsquo;m really tired of hearing folks (incorrectly) state &ldquo;primitives are passed by value, objects are passed by reference&rdquo;.</p>
<p>I&rsquo;m a compiler guy at heart. The terms &ldquo;pass-by-value&rdquo; semantics and &ldquo;pass-by-reference&rdquo; semantics have very precise definitions, and they&rsquo;re often horribly abused when folks talk about Java. I want to correct that&hellip; The following is how I&rsquo;d describe these</p>
<h2 id="pass-by-value">Pass-by-value</h2>
<p>The actual parameter (or argument expression) is fully evaluated and the resulting value is <em>copied</em> into a location being used to hold the formal parameter&rsquo;s value during method/function execution. That location is typically a chunk of memory on the runtime stack for the application (which is how Java handles it), but other languages could choose parameter storage differently.</p>
<h2 id="pass-by-reference">Pass-by-reference</h2>
<p>The formal parameter merely acts as an <em>alias</em> for the actual parameter. Anytime the method/function uses the formal parameter (for reading or writing), it is actually using the actual parameter.</p>
<p>Java is <strong><em>strictly</em></strong> pass-by-value, exactly as in C. Read the Java Language Specification (JLS). It&rsquo;s spelled out, and it&rsquo;s correct. In <a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.1">https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.1</a>:</p>
<blockquote>
<p>When the method or constructor is invoked (§15.12), the <strong><em>values</em></strong> of the actual argument expressions initialize newly created parameter variables, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the FormalParameter may be used as a simple name in the body of the method or constructor to refer to the formal parameter.</p>
</blockquote>
<p>Note: In the above, <em><strong>values</strong></em> is my emphasis, not theirs</p>
<p>Section 15.12.4.2 (<a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12.4.2">https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12.4.2</a>) states:</p>
<blockquote>
<p>The argument expressions (possibly rewritten as described above) are now evaluated to yield <em>argument values</em>. Each argument value corresponds to exactly one of the method&rsquo;s n formal parameters.</p>
</blockquote>
<p>In short: Java <strong><em>has</em></strong> pointers and is strictly pass-by-value. There are no special rules. It&rsquo;s simple, clean, and clear. (Well, as clear as the evil C++-like syntax will allow ;)</p>
<p><em>Note: See the note at the end of this article, &ldquo;A Note on Remote Method Invocation&rdquo;, for the semantics of remote method invocation (RMI). What is typically called &ldquo;pass by reference&rdquo; for remote objects is actually incredibly bad semantics.</em></p>
<hr>
<h1 id="the-litmus-test">The Litmus Test</h1>
<p>There&rsquo;s a simple &ldquo;litmus test&rdquo; for whether a language supports pass-by-reference semantics:</p>
<p><em>Can you write a traditional swap(a,b) method/function in the language?</em></p>
<p>A traditional swap method or function takes two arguments and swaps them such that variables passed into the function are changed outside the function. Its basic structure looks like</p>
<pre tabindex="0"><code>swap(Type arg1, Type arg2) {
    Type temp = arg1;
    arg1 = arg2;
    arg2 = temp;
}
</code></pre><p>If you can write such a method/function in your language such that calling</p>
<pre tabindex="0"><code>Type var1 = ...;
Type var2 = ...;
swap(var1,var2);
</code></pre><p>actually switches the values of the variables <code>var1</code> and <code>var2</code>, the language supports pass-by-reference semantics.</p>
<p>For example, in Pascal, you can write</p>
<pre tabindex="0"><code class="language-pascal" data-lang="pascal">procedure swap(var arg1, arg2: SomeType);
var
    temp : SomeType;
begin
    temp := arg1;
    arg1 := arg2;
    arg2 := temp;
end;
<p>...</p>
<p>{ in some other procedure/function/program }</p>
<p>var<br>
var1, var2 : SomeType;</p>
<p>begin<br>
var1 := ...; { value &quot;A&quot; }<br>
var2 := ...; { value &quot;B&quot; }<br>
swap(var1, var2);<br>
{ now var1 has value &quot;B&quot; and var2 has value &quot;A&quot; }<br>
end;<br>
</code></pre><p>or in C++ you could write</p></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">SomeType</span><span class="o">&amp;</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">Sometype</span><span class="o">&amp;</span> <span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SomeType</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span>
    <span class="n">arg1</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">;</span>
    <span class="n">arg2</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<p><span class="p">...</span></p>
<p><span class="n">SomeType</span> <span class="n">var1</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// value &quot;A&quot;<br>
</span><span class="c1"></span><span class="n">SomeType</span> <span class="n">var2</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// value &quot;B&quot;<br>
</span><span class="c1"></span><span class="n">swap</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">);</span> <span class="c1">// swaps their values!<br>
</span><span class="c1">// now var1 has value &quot;B&quot; and var2 has value &quot;A&quot;<br>
</span></code></pre></div><p>(Please let me know if my Pascal or C++ has lapsed and I’ve messed up the syntax…)</p></p>
<p>But you <em>cannot</em> do this in Java!</p>
<hr>
<h1 id="now-the-details">Now the details</h1>
<p>The problem we&rsquo;re facing here is statements like</p>
<p><em>In Java, Objects are passed by reference, and primitives are passed by value.</em></p>
<p>This is half incorrect. Everyone can easily agree that primitives are passed by value; there&rsquo;s no such thing in Java as a pointer/reference to a primitive.</p>
<p>However, <em>Objects are <strong>not</strong> passed by reference</em>. A correct statement would be <em>Object references are passed by value</em>.</p>
<p>This may seem like splitting hairs, but it is <em>far</em> from it. There is a world of difference in meaning. The following examples should help make the distinction.</p>
<p>In Java, take the case of</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">(</span><span class="n">Dog</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="o">(</span><span class="s">&#34;Fifi&#34;</span><span class="o">);</span> <span class="c1">// creating the &#34;Fifi&#34; dog
</span><span class="c1"></span><span class="o">}</span>
<p><span class="n">Dog</span> <span class="n">aDog</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="o">(</span><span class="s">&quot;Max&quot;</span><span class="o">);</span> <span class="c1">// creating the &quot;Max&quot; dog<br>
</span><span class="c1"></span><br>
<span class="c1">// at this point, aDog points to the &quot;Max&quot; dog<br>
</span><span class="c1"></span><br>
<span class="n">foo</span><span class="o">(</span><span class="n">aDog</span><span class="o">);</span></p>
<p><span class="c1">// aDog still points to the &quot;Max&quot; dog<br>
</span></code></pre></div><p>the variable passed in, <code>aDog</code>, <strong><em>is not</em></strong> modified! After calling <code>foo()</code>, <code>aDog</code> <strong><em>still</em></strong> points to the <code>Dog</code> with name “Max”!</p></p>
<p>Many people mistakenly think/state that something like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">(</span><span class="n">Dog</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span> 
    <span class="n">d</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;Fifi&#34;</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>shows that Java does in fact pass objects by reference.</p>
<p>The mistake they make is in the definition of</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Dog</span> <span class="n">d</span><span class="o">;</span>
</code></pre></div><p>itself. When you write that definition, you are defining a <em>pointer</em> to a <code>Dog</code> object, <em>not</em> a <code>Dog</code> object itself.</p>
<h2 id="on-pointers-versus-references">On Pointers versus References&hellip;</h2>
<p>The problem here is that the folks at Sun made a naming mistake.</p>
<p>In programming language design, a &ldquo;pointer&rdquo; is a variable that indirectly tracks the location of some piece of data. The value of a pointer is often the memory address of the data you&rsquo;re interested in. Some languages allow you to manipulate that address; others do not.</p>
<p>A &ldquo;reference&rdquo; is an alias to another variable. Any manipulation done to the reference variable directly changes the original variable.</p>
<p>Check out the second sentence of <a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.3.1">https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.3.1</a>.</p>
<blockquote>
<p>The reference values (often just references) are pointers to these objects, and a special null reference, which refers to no object.</p>
</blockquote>
<p><em>They</em> explicitly say &ldquo;pointers&rdquo; in their description&hellip; Interesting&hellip;</p>
<p>When they were originally creating Java, they had &ldquo;pointer&rdquo; in mind (you can see some remnants of this in classes like <code>NullPointerException</code>).</p>
<p>Sun wanted to push Java as a secure language, and one of Java&rsquo;s advantages was that it does not allow pointer <em>arithmetic</em> as C++ does.</p>
<p>They went so far as to try a different name for the concept, formally calling them &ldquo;references&rdquo;. A <em>huge</em> mistake and it&rsquo;s caused even more confusion in the process.</p>
<p>There&rsquo;s an excellent explanation of reference variables at <a href="http://www.cprogramming.com/tutorial/references.html">http://www.cprogramming.com/tutorial/references.html</a>. It&rsquo;s C++ specific, but it properly says the concept of a true reference variable.</p>
<p>The word &ldquo;reference&rdquo; in programming language design originally comes from how you <em>pass</em> data to subroutines/functions/procedures/methods. A reference <em>parameter</em> is an <em>alias</em> to a variable passed as a parameter.</p>
<p>In the end, Sun made a naming mistake that&rsquo;s caused confusion. Java has pointers, and once you accept that, it makes the way Java behaves make much more sense.</p>
<h2 id="calling-methods">Calling Methods</h2>
<p>Calling</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">foo</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
</code></pre></div><p>passes the <strong><em>value of <code>d</code></em></strong> to <code>foo()</code>; it does <em>not</em> pass the object that <code>d</code> points to!</p>
<p>The value of the pointer being passed is similar to a memory address. Under the covers it may be a tad different, but from a programmer&rsquo;s perspective, you can think of it in exactly the same way. <em>The value uniquely identifies some object on the heap</em>.</p>
<p><strong><em>However,</em></strong> it makes <em>no</em> difference how pointers are <strong><em>implemented</em></strong> under the covers. You program with them <strong><em>exactly</em></strong> the same way in Java as you would in C or C++. The syntax is just slightly different (another poor choice in Java&rsquo;s design; they should have used the same <code>-&gt;</code> syntax for de-referencing as C++).</p>
<p>In Java,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Dog</span> <span class="n">d</span><span class="o">;</span>
</code></pre></div><p>is <strong><em>exactly</em></strong> like C++&rsquo;s</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Dog</span> <span class="o">*</span><span class="n">d</span><span class="o">;</span>
</code></pre></div><p>And using</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">d</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;Fifi&#34;</span><span class="o">);</span>
</code></pre></div><p>is exactly like C++&rsquo;s</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">d</span><span class="o">-&gt;</span><span class="n">setName</span><span class="p">(</span><span class="s">&#34;Fifi&#34;</span><span class="p">);</span>
</code></pre></div><p>To sum up: Java <strong><em>has</em></strong> pointers, and the <strong><em>value</em></strong> of the <strong><em>pointer</em></strong> is passed in. There&rsquo;s no way to actually pass an object itself as a parameter. You can only pass a pointer to an object.</p>
<p>Keep in mind, when you call</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">foo</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
</code></pre></div><p>you&rsquo;re not passing an object; you&rsquo;re passing a <em>pointer</em> to the object.</p>
<p>For a slightly different (but still correct) take on this issue, please see Praxis 1 in Peter Haggar&rsquo;s excellent book, <em>Practical Java</em>: <a href="https://books.google.com/books?id=iWPeqljHNcoC&amp;lpg=PP1&amp;pg=PA1">https://books.google.com/books?id=iWPeqljHNcoC&amp;lpg=PP1&amp;pg=PA1</a>.</p>
<hr>
<h1 id="a-note-on-remote-method-invocation-rmi">A Note on Remote Method Invocation (RMI)</h1>
<p>When passing parameters to remote methods, things get a bit more complex. First, we&rsquo;re (usually) dealing with passing data between two independent virtual machines, which might be on separate physical machines as well. Passing the value of a pointer wouldn&rsquo;t do any good, as the target virtual machine doesn&rsquo;t have access to the caller&rsquo;s heap.</p>
<p>You&rsquo;ll often hear &ldquo;pass by value&rdquo; and &ldquo;pass by reference&rdquo; used with respect to RMI. These terms have more of a &ldquo;logical&rdquo; meaning, and really aren&rsquo;t correct for the intended use.</p>
<p>Here&rsquo;s what is usually meant by these phrases with regard to RMI. Note that this is <em>not</em> proper usage of &ldquo;pass by value&rdquo; and &ldquo;pass by reference&rdquo; semantics:</p>
<h2 id="rmi-pass-by-value">RMI &ldquo;Pass-by-value&rdquo;</h2>
<p>The actual parameter is <em>serialized</em> and passed using a network protocol to the target remote object. Serialization essentially &ldquo;squeezes&rdquo; the data out of an object/primitive. On the receiving end, that data is used to build a &ldquo;clone&rdquo; of the original object or primitive. Note that this process can be rather expensive if the actual parameters point to large objects (or large graphs of objects).</p>
<p><strong>This isn&rsquo;t quite the right use of &ldquo;pass-by-value&rdquo;; I think it should really be called something like &ldquo;pass-by-memento&rdquo;. (See &ldquo;Design Patterns&rdquo; by Gamma et al for a description of the Memento pattern).</strong><br>
 </p>
<h2 id="rmi-pass-by-reference">RMI &ldquo;Pass-by-reference&rdquo;</h2>
<p>The actual parameter, which <em>is itself a remote object</em>,  is represented by a proxy. The proxy keeps track of where the actual parameter lives, and anytime the target method uses the formal parameter, <em>another remote method invocation occurs</em> to &ldquo;call back&rdquo; to the actual parameter. This can be useful if the actual parameter points to a large object (or graph of objects) and there are few call backs.</p>
<p><strong>This isn&rsquo;t quite the right use of &ldquo;pass-by-reference&rdquo; (again, you cannot change the actual parameter itself). I think it should be called something like &ldquo;pass-by-proxy&rdquo;. (Again, see &ldquo;Design Patterns&rdquo; for descriptions of the Proxy pattern).</strong></p>
<hr>
<h1 id="follow-up-from-stackoverflowcom">Follow up from stackoverflow.com</h1>
<p>The Java Spec says that everything in java is pass-by-value. There is no such thing as &ldquo;pass-by-reference&rdquo; in java.</p>
<p>The key to understanding this is that something like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Dog</span> <span class="n">myDog</span><span class="o">;</span>
</code></pre></div><p>is not a Dog; it&rsquo;s actually a pointer to a Dog.</p>
<p>What that means, is when you have</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Dog</span> <span class="n">myDog</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="o">(</span><span class="s">&#34;Rover&#34;</span><span class="o">);</span>
<span class="n">foo</span><span class="o">(</span><span class="n">myDog</span><span class="o">);</span>
</code></pre></div><p>you&rsquo;re essentially passing the address of the created Dog object to the foo method. (I say essentially b/c java pointers aren&rsquo;t direct addresses, but it&rsquo;s easiest to think of them that way)</p>
<p>Suppose the Dog object resides at memory address 42. This means we pass 42 to the method.</p>
<p>If the Method were defined as</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">(</span><span class="n">Dog</span> <span class="n">someDog</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// AAA
</span><span class="c1"></span>    <span class="n">someDog</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;Max&#34;</span><span class="o">);</span>     <span class="c1">// BBB
</span><span class="c1"></span>    <span class="n">someDog</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="o">(</span><span class="s">&#34;Fifi&#34;</span><span class="o">);</span>  <span class="c1">// CCC
</span><span class="c1"></span>    <span class="n">someDog</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;Rowlf&#34;</span><span class="o">);</span>   <span class="c1">// DDD
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>Let&rsquo;s look at what&rsquo;s happening.</p>
<ul>
<li>
<p>line AAA</p>
<ul>
<li>the parameter <code>someDog</code> is set to the value 42</li>
</ul>
</li>
<li>
<p>line BBB</p>
<ul>
<li>
<p><code>someDog</code> is followed to the <code>Dog</code> it points to (the <code>Dog</code> object at address 42)</p>
</li>
<li>
<p>that <code>Dog</code> (the one at address 42) is asked to change his name to &ldquo;Max&rdquo;</p>
</li>
</ul>
</li>
<li>
<p>line CCC</p>
<ul>
<li>a new <code>Dog</code> is created. Let&rsquo;s say he&rsquo;s at address 74.</li>
<li>we assign the parameter <code>someDog</code> to that address, 74</li>
</ul>
</li>
<li>
<p>line DDD</p>
<ul>
<li><code>someDog</code> is followed to the <code>Dog</code> it points to (the <code>Dog</code> object at address 74)</li>
<li>that <code>Dog</code> (the one at address 74) is asked to change his name to &ldquo;Rowlf&rdquo;</li>
</ul>
</li>
</ul>
<p>Now let&rsquo;s think about what happens outside the method:</p>
<p><em><strong>Did myDog change?</strong></em></p>
<p>There&rsquo;s the key.</p>
<p>Keeping in mind that <code>myDog</code> is a pointer, and not an actual <code>Dog</code>, the answer is <strong><em>NO</em></strong>. <code>myDog</code> still has the value 42; it&rsquo;s still pointing to the original <code>Dog</code>.</p>
<p>It&rsquo;s perfectly valid to follow an address and change what&rsquo;s at the end of it; that does not change the variable, however.</p>
<p>Java works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, you cannot change where that pointer points.</p>
<p>In C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.</p>
<p>If Java had pass-by-reference semantics, the foo method we defined above would have changed where <code>myDog</code> was pointing when it assigned someDog on line CCC.</p>
<p>Think of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ADT与OOP]]></title>
        <id>https://guozixu2001.github.io/post/adt-yu-oop/</id>
        <link href="https://guozixu2001.github.io/post/adt-yu-oop/">
        </link>
        <updated>2022-04-30T10:06:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="adt">ADT</h1>
<p>在认识ADT之前，首先我们来思考，什么是抽象？<br>
从抽象数据类型可以衍生出很多意思相近的名词，这里列出几个能表达其中思想的词：</p>
<ul>
<li>抽象：忽略底层的细节而在更高层思考</li>
<li>模块化：将系统分为一个个模块，每个模块可以单独地进行设计、实现、测试、推导，并且在剩下的开发中进行复用</li>
<li>封装：在模块外部建立起一道“围墙”，使它只对自己内部的行为负责，并且系统其它地方的代码不会影响到它的内部</li>
<li>信息隐藏：将模块的实现细节隐藏，使未来更改模块内部时不必改变外部代码</li>
<li>功能分离：一个模块仅仅负责一个特性/功能，而不是将一个特性运用在很多模块或一个模块拥有很多特性<br>
<strong>更深入的理解</strong><br>
抽象：规约使得使用者只需要弄懂规约并遵守前置条件，而不需要弄懂底层的代码实现模块化：单元测试和规约都帮助将方法模块化封装：方法中的局部变量都是被封装起来的，因为它们仅仅可以在方法内部使用。与此相对的是全局变量和指向可变对象的别名，它们会对封装带来很大损害信息隐藏：规约就是一种信息隐藏，它使得实现者可以自由地更改实现代码功能分离：一个规约应该是逻辑明确的，即它不能有很多特性，而应只需实现一种功能</li>
</ul>
<p><strong>如何设计ADT？</strong><br>
设计ADT：设计规约Spec-&gt;表示不变性Rep-&gt;实现Impl</p>
<p><strong>规约Spec的写法：</strong></p>
<blockquote>
<p>更相似的见下篇《设计规约》</p>
</blockquote>
<ul>
<li>方法注释</li>
<li>@param 参数说明</li>
<li>@return 返回值说明</li>
<li>@throw 抛出异常</li>
</ul>
<p><strong>规约Spec的强度：</strong><br>
前置条件越弱，规约强度越强；<br>
后置条件越强，规约强度越强；<br>
其他情况无法比较。<br>
<strong>规约Spec的评价：</strong></p>
<ul>
<li>内聚的：一个好的规约Spec应该功能单一，易于理解；</li>
<li>信息丰富的：不产生歧义；</li>
<li>足够“强”的：使开发人员应该考虑足够多的异常情况并进行处理；</li>
<li>足够“弱”的：为开发人员减轻工作负担并降低开发成本。</li>
</ul>
<p><strong>抽象函数AF：</strong><br>
表示R(表示空间)和A(抽象空间)之间关系的一个映射<br>
AF:R-&gt;A；</p>
<p><strong>表示不变量RI：</strong><br>
描述什么是合法的表示值，是所有表示值的一个子集。</p>
<p><strong>ADT实现Impl(表示泄露)</strong><br>
  通过防御式拷贝，给客户端返回一个全新的对象，即使客户端修改了数据，也不会影响自己。然而大量的拷贝会占用内存空间，因此很多时候会使用不可变数据类型以节省频繁复制的代价。</p>
<p><strong>ADT测试Test</strong><br>
  需要注意的是，由于测试时开发者也相当于用户，因此不能直接访问ADT内部的数据域，只能调用其他方法测试待测的方法。</p>
<ul>
<li>针对creater：构造对象后，用observer观察是否正确；</li>
<li>针对observer：用其他方法构造对象，调用被测observer，观察判断结果是否正确；</li>
<li>针对producer：produce一个新的对象，用observer观察结果是否正确。</li>
</ul>
<h1 id="oop">OOP</h1>
<h2 id="基本概念">基本概念</h2>
<p><strong>接口(Interface):</strong><br>
接口之间可以继承与扩展；<br>
一个类可以实现多个接口；<br>
一个接口可以有多个实现类。</p>
<p><strong>重写：</strong></p>
<ul>
<li>参数列表必须与父类完全相同；</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低；</li>
<li>声明为 final 的方法不能被重写；</li>
<li>构造方法不能被重写；</li>
<li>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</li>
</ul>
<p><strong>多态：</strong><br>
  多态是同一个行为具有多种不同表现形式或形态的能力，可以消除类型之间的耦合关系</p>
<h1 id="adt和oop中的等价性">ADT和OOP中的等价性</h1>
<h2 id="不可变对象">不可变对象</h2>
<ul>
<li>引用等价性与对象等价性<br>
“==”是引用等价，即两个引用指向了相同的内存空间；<br>
“equals()”是对象等价，即两个对象的域相同。</li>
<li>如何判断两个不可变对象相等<br>
如果AF映射到同样的结果则等价。在自定义ADT中，如果要判断等价，需要重写equals()方法和hashCode()方法。</li>
</ul>
<h2 id="可变对象">可变对象</h2>
<p><strong>观察等价性与行为等价性：</strong></p>
<ul>
<li>观察等价性：在不改变状态的情况下，两个可变对象看起来是否一致；</li>
<li>行为等价性：调用对象的任何方法表现出一致的结果。<br>
  对可变数据类型，往往倾向于实现严格的观察等价性，但有些时候可能导致bud，甚至破坏RI。对于可变数据类型，无需重写equals()f方法和hashCode()方法，直接继承自Object即可，而如果一定要判断两个可变对象看起来是否一致，最好定义一个新的方法。</li>
</ul>
<p><strong>总结</strong><br>
等价性应该是一种等价关系；<br>
抽象函数AF是等价性的基础。</p>
]]></content>
    </entry>
</feed>